1. we need a EdgedbComposableSelector trait

        pub trait EdgedbComposableSelector {
            const RESULT_TYPE: ComposableQueryResultKind;

            fn format_selector(fmt: &mut impl std::fmt::Write) -> Result<(), std::fmt::Error>;

            fn format_subquery(fmt: &mut impl std::fmt::Write) -> Result<(), std::fmt::Error>;
        }

    I already have it...

2. I think maybe we should expose queries stuff in runtime? maybe later. i have a lot written already

3. so we need a EdgedbComposableQuery: EdgedbComposableSelector trait
    should it depend on EdgedbObject ?.. i think not


        pub trait ComposableQuery: EdgedbComposableSelector {
            const ARG_NAMES: &'static [&'static str];

            type ArgTypes: EdgedbArgs;    
                // EdgebArgs ???? not sure? i mean if it's composable...
                // no it still needs to be EdgedbArgs, a tuple

            type ReturnType: EdgedbArgs;  // EdgedbObject ... actually EdgedbSetValue 

            fn format_query(
                fmt: &mut impl std::fmt::Write,
                args: &::std::collections::HashMap<&str, String>,
            ) -> Result<(), std::fmt::Error>;

            fn query() -> String {}
        }

4. and then docs and other crap. actually i should start with examples!